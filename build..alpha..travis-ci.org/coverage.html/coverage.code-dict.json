{"/home/travis/build/npmtest/node-npmtest-react-native-router-flux/test.js":"/* istanbul instrument in package npmtest_react_native_router_flux */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/lib.npmtest_react_native_router_flux.js":"/* istanbul instrument in package npmtest_react_native_router_flux */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_react_native_router_flux = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_react_native_router_flux = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-react-native-router-flux && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_react_native_router_flux */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_react_native_router_flux\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_react_native_router_flux.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_react_native_router_flux.rollup.js'] =\n            local.assetsDict['/assets.npmtest_react_native_router_flux.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_react_native_router_flux.__dirname + '/lib.npmtest_react_native_router_flux.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/index.js":"import Actions from './src/Actions';\nimport * as ActionConst from './src/ActionConst';\nimport DefaultRenderer from './src/DefaultRenderer';\nimport TabbedView from './src/TabbedView';\nimport Modal from './src/Modal';\nimport NavBar from './src/NavBar';\nimport Reducer from './src/Reducer';\nimport Router from './src/Router';\nimport Scene from './src/Scene';\nimport Switch from './src/Switch';\nimport TabBar from './src/TabBar';\nimport getInitialStateFromRoot from './src/State';\nimport Util from './src/Util';\n\nexport {\n  Actions,\n  ActionConst,\n  DefaultRenderer,\n  Modal,\n  NavBar,\n  Reducer,\n  Router,\n  Scene,\n  Switch,\n  TabBar,\n  TabbedView,\n  getInitialStateFromRoot,\n  Util,\n};\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/.eslintrc.js":"module.exports = {\n  extends: 'airbnb',\n  plugins: [\n    'react',\n  ],\n  parser: 'babel-eslint',\n  rules: {\n    'react/forbid-prop-types': 0,\n    'no-console': 0,\n    'import/no-unresolved': [\n      2,\n      {\n        ignore: [\n          '^react$',\n          '^react-native$',\n          '^react-native/',\n        ],\n      },\n    ],\n    'react/jsx-filename-extension': [\n      1,\n      {\n        extensions: [\n          '.js',\n          '.jsx',\n        ],\n      },\n    ],\n    'import/no-extraneous-dependencies': [\n      'error',\n      {\n        'devDependencies': true,\n      }\n    ],\n    'no-bitwise': [\n      'error',\n      {\n        'allow': ['^'],\n      },\n    ],\n    'no-restricted-syntax': [\n      'error',\n      'ForInStatement',\n      'LabeledStatement',\n      'WithStatement',\n    ],\n  },\n  settings: {\n    'import/resolver': {\n      node: {\n        extensions: [\n          '.js',\n          '.android.js',\n          '.ios.js',\n        ],\n      },\n    },\n    node: true,\n  },\n};\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/ActionConst.js":"export const JUMP = 'REACT_NATIVE_ROUTER_FLUX_JUMP';\nexport const PUSH = 'REACT_NATIVE_ROUTER_FLUX_PUSH';\nexport const PUSH_OR_POP = 'REACT_NATIVE_ROUTER_FLUX_PUSH_OR_POP';\nexport const REPLACE = 'REACT_NATIVE_ROUTER_FLUX_REPLACE';\nexport const BACK = 'REACT_NATIVE_ROUTER_FLUX_BACK';\nexport const BACK_ACTION = 'REACT_NATIVE_ROUTER_FLUX_BACK_ACTION';\nexport const POP_AND_REPLACE = 'REACT_NATIVE_ROUTER_FLUX_POP_AND_REPLACE';\nexport const POP_TO = 'REACT_NATIVE_ROUTER_FLUX_POP_TO';\nexport const REFRESH = 'REACT_NATIVE_ROUTER_FLUX_REFRESH';\nexport const RESET = 'REACT_NATIVE_ROUTER_FLUX_RESET';\nexport const FOCUS = 'REACT_NATIVE_ROUTER_FLUX_FOCUS';\nexport const ANDROID_BACK = 'REACT_NATIVE_ROUTER_FLUX_ANDROID_BACK';\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/Actions.js":"/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { assert } from './Util';\nimport Scene from './Scene';\nimport * as ActionConst from './ActionConst';\n\nexport const ActionMap = {\n  jump: ActionConst.JUMP,\n  push: ActionConst.PUSH,\n  replace: ActionConst.REPLACE,\n  back: ActionConst.BACK,\n  BackAction: ActionConst.BACK_ACTION,\n  popAndReplace: ActionConst.POP_AND_REPLACE,\n  popTo: ActionConst.POP_TO,\n  refresh: ActionConst.REFRESH,\n  reset: ActionConst.RESET,\n  focus: ActionConst.FOCUS,\n  pushOrPop: ActionConst.PUSH_OR_POP,\n  androidBack: ActionConst.ANDROID_BACK,\n  [ActionConst.JUMP]: ActionConst.JUMP,\n  [ActionConst.PUSH]: ActionConst.PUSH,\n  [ActionConst.REPLACE]: ActionConst.REPLACE,\n  [ActionConst.BACK]: ActionConst.BACK,\n  [ActionConst.BACK_ACTION]: ActionConst.BACK_ACTION,\n  [ActionConst.POP_AND_REPLACE]: ActionConst.POP_AND_REPLACE,\n  [ActionConst.POP_TO]: ActionConst.POP_TO,\n  [ActionConst.REFRESH]: ActionConst.REFRESH,\n  [ActionConst.RESET]: ActionConst.RESET,\n  [ActionConst.FOCUS]: ActionConst.FOCUS,\n  [ActionConst.PUSH_OR_POP]: ActionConst.PUSH_OR_POP,\n  [ActionConst.ANDROID_BACK]: ActionConst.ANDROID_BACK,\n};\n\nfunction filterParam(data) {\n  if (data.toString() !== '[object Object]') {\n    return { data };\n  }\n  const proto = (data || {}).constructor.name;\n  // avoid passing React Native parameters\n  if (!data || (proto !== 'Object')) {\n    return {};\n  }\n  return data;\n}\n\nconst reservedKeys = [\n  'create',\n  'callback',\n  'iterate',\n  'current',\n  ...Object.keys(ActionMap),\n];\n\nfunction getInheritProps(props) {\n  // eslint-disable-next-line no-unused-vars\n  const { key, style, type, component, tabs, sceneKey, parent, children, ...parentProps } = props;\n  return parentProps.passProps ? parentProps : {};\n}\n\nclass Actions {\n  constructor() {\n    this.callback = null;\n    this.create = this.create.bind(this);\n    this.iterate = this.iterate.bind(this);\n    this.pop = this.pop.bind(this);\n    this.refresh = this.refresh.bind(this);\n    this.focus = this.focus.bind(this);\n  }\n\n  iterate(root: Scene, parentProps = {}, refsParam = {}, wrapBy) {\n    const refs = refsParam;\n    assert(root.props, 'props should be defined for stack');\n    const key = root.key;\n    assert(key, 'unique key should be defined ');\n    assert(\n      reservedKeys.indexOf(key) === -1,\n      `'${key}' is not allowed as key name. Reserved keys: [${reservedKeys.join(', ')}]`,\n    );\n    const { children, component, ...staticProps } = root.props;\n    let type = root.props.type || (parentProps.tabs ? ActionConst.JUMP : ActionConst.PUSH);\n    if (type === 'switch') {\n      type = ActionConst.JUMP;\n    }\n    const inheritProps = getInheritProps(parentProps);\n    const componentProps = component ? { component: wrapBy(component) } : {};\n    // wrap other components\n    if (wrapBy) {\n      Object.keys(staticProps).forEach((prop) => {\n        const componentClass = staticProps[prop];\n        if (componentClass && componentClass.prototype && componentClass.prototype.render) {\n          componentProps[prop] = wrapBy(componentClass);\n          delete staticProps[prop];\n        }\n      });\n    }\n    const res = {\n      key,\n      name: key,\n      sceneKey: key,\n      parent: parentProps.key,\n      type,\n      ...inheritProps,\n      ...staticProps,\n      ...componentProps,\n    };\n    let list = children || [];\n    const normalized = [];\n    if (!(list instanceof Array)) {\n      list = [list];\n    }\n    list.forEach((item) => {\n      if (item) {\n        if (item instanceof Array) {\n          item.forEach((it) => {\n            normalized.push(it);\n          });\n        } else {\n          normalized.push(item);\n        }\n      }\n    });\n    list = normalized; // normalize the list of scenes\n\n    const condition = el => (!el.props.component && !el.props.children && !el.props.onPress &&\n    (!el.props.type || ActionMap[el.props.type] === ActionConst.REFRESH));\n    // determine sub-states\n    let baseKey = root.key;\n    let subStateParent = parentProps.key;\n    const subStates = list.filter(condition);\n    list = list.filter(el => !condition(el));\n    if (list.length) {\n      res.children = list.map(c => this.iterate(c, res, refs, wrapBy).key);\n    } else {\n      if (!staticProps.onPress) {\n        assert(component, `component property is not set for key=${key}`);\n      }\n      // wrap scene if parent is \"tabs\"\n      if (parentProps.tabs) {\n        const innerKey = `${res.key}_`;\n        baseKey = innerKey;\n        subStateParent = res.key;\n        const inner = { ...res,\n          name: key,\n          key: innerKey,\n          sceneKey: innerKey,\n          type: ActionConst.PUSH,\n          parent: res.key };\n        refs[innerKey] = inner;\n        res.children = [innerKey];\n        delete res.component;\n      }\n      res.index = 0;\n    }\n    // process substates\n    for (const el of subStates) {\n      refs[el.key] = { key: el.key,\n        name: el.key,\n        ...el.props,\n        type: ActionConst.REFRESH,\n        base: baseKey,\n        parent: subStateParent };\n      if (this[el.key]) {\n        console.log(`Key ${el.key} is already defined!`);\n      }\n      this[el.key] =\n        (props = {}) => {\n          assert(this.callback, 'Actions.callback is not defined!');\n          this.callback({ key: el.key, type: ActionConst.REFRESH, ...filterParam(props) });\n        };\n    }\n    if (this[key]) {\n      console.log(`Key ${key} is already defined!`);\n    }\n    this[key] =\n      (props = {}) => {\n        assert(this.callback, 'Actions.callback is not defined!');\n        this.callback({ key, type, ...filterParam(props) });\n      };\n    refs[res.key] = res;\n\n    return res;\n  }\n\n  popTo(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.POP_TO });\n  }\n\n  pop(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.BACK_ACTION });\n  }\n\n  jump(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.JUMP });\n  }\n\n  refresh(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.REFRESH });\n  }\n\n  focus(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.FOCUS });\n  }\n\n  androidBack(props = {}) {\n    return this.callback({ ...filterParam(props), type: ActionConst.ANDROID_BACK });\n  }\n\n  create(scene:Scene, wrapBy = x => x) {\n    assert(scene, 'root scene should be defined');\n    const refs = {};\n    this.iterate(scene, {}, refs, wrapBy);\n    return refs;\n  }\n}\n\nexport { Actions as ActionsTest };\nexport default new Actions();\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/DefaultRenderer.js":"/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport React, {\n  Component,\n  PropTypes,\n} from 'react';\nimport {\n  Animated,\n  View,\n  StyleSheet,\n  Dimensions,\n} from 'react-native';\nimport NavigationExperimental from 'react-native-experimental-navigation';\nimport PureRenderMixin from 'react-addons-pure-render-mixin';\n\nimport TabBar from './TabBar';\nimport NavBar from './NavBar';\nimport Actions from './Actions';\nimport { deepestExplicitValueForKey } from './Util';\n\nconst SCREEN_WIDTH = Dimensions.get('window').width;\n\nconst {\n  AnimatedView: NavigationAnimatedView,\n  Card: NavigationCard,\n} = NavigationExperimental;\n\nconst {\n  CardStackPanResponder: NavigationCardStackPanResponder,\n  CardStackStyleInterpolator: NavigationCardStackStyleInterpolator,\n} = NavigationCard;\n\nconst styles = StyleSheet.create({\n  animatedView: {\n    flex: 1,\n    backgroundColor: 'transparent',\n  },\n  sceneStyle: {\n    flex: 1,\n  },\n});\n\nfunction fadeInScene(/* NavigationSceneRendererProps */ props) {\n  const {\n    position,\n    scene,\n  } = props;\n\n  const index = scene.index;\n  const inputRange = [index - 1, index, index + 1];\n\n  const opacity = position.interpolate({\n    inputRange,\n    outputRange: [0, 1, 0.3],\n  });\n\n  const scale = position.interpolate({\n    inputRange,\n    outputRange: [1, 1, 0.95],\n  });\n\n  const translateY = 0;\n  const translateX = 0;\n\n  return {\n    opacity,\n    transform: [\n      { scale },\n      { translateX },\n      { translateY },\n    ],\n  };\n}\n\nfunction leftToRight(/* NavigationSceneRendererProps */ props) {\n  const {\n    position,\n    scene,\n  } = props;\n\n  const index = scene.index;\n  const inputRange = [index - 1, index, index + 1];\n\n  const translateX = position.interpolate({\n    inputRange,\n    outputRange: [-SCREEN_WIDTH, 0, 0],\n  });\n\n  return {\n    transform: [\n      { translateX },\n    ],\n  };\n}\n\nexport default class DefaultRenderer extends Component {\n\n  static propTypes = {\n    navigationState: PropTypes.object,\n    onNavigate: PropTypes.func,\n  };\n\n  static childContextTypes = {\n    navigationState: PropTypes.any,\n  };\n\n  static getPanHandlers(direction, props) {\n    return direction === 'vertical' ?\n      NavigationCardStackPanResponder.forVertical(props) :\n      NavigationCardStackPanResponder.forHorizontal(props);\n  }\n\n  static dispatchFocusAction({ navigationState }) {\n    if (!navigationState || navigationState.component || navigationState.tabs) {\n      return;\n    }\n    const scene = navigationState.children[navigationState.index];\n    Actions.focus({ scene });\n  }\n\n  static chooseInterpolator(direction, props) {\n    switch (direction) {\n      case 'vertical':\n        return NavigationCardStackStyleInterpolator.forVertical(props);\n      case 'fade':\n        return fadeInScene(props);\n      case 'leftToRight':\n        return leftToRight(props);\n      default:\n        return NavigationCardStackStyleInterpolator.forHorizontal(props);\n    }\n  }\n\n  static renderScene(/* NavigationSceneRendererProps */ props) {\n    return (\n      <DefaultRenderer\n        key={props.scene.navigationState.key}\n        onNavigate={props.onNavigate}\n        navigationState={props.scene.navigationState}\n      />\n    );\n  }\n\n  static renderHeader(/* NavigationSceneRendererProps */ props) {\n    const state = props.navigationState;\n    const child = state.children[state.index];\n    let selected = state.children[state.index];\n    while ({}.hasOwnProperty.call(selected, 'children')) {\n      selected = selected.children[selected.index];\n    }\n    if (child !== selected) {\n      // console.log(`SKIPPING renderHeader because ${child.key} !== ${selected.key}`);\n      return null;\n    }\n    const hideNavBar = deepestExplicitValueForKey(state, 'hideNavBar');\n    if (hideNavBar) {\n      // console.log(`SKIPPING renderHeader because ${child.key} hideNavBar === true`);\n      return null;\n    }\n\n    // console.log(`renderHeader for ${child.key}`);\n\n    if (selected.component && selected.component.renderNavigationBar) {\n      return selected.component.renderNavigationBar({ ...props, ...selected });\n    }\n\n    const HeaderComponent = selected.navBar || child.navBar || state.navBar || NavBar;\n    const navBarProps = { ...state, ...child, ...selected };\n\n    if (selected.component && selected.component.onRight) {\n      navBarProps.onRight = selected.component.onRight;\n    }\n\n    if (selected.component && selected.component.onLeft) {\n      navBarProps.onLeft = selected.component.onLeft;\n    }\n\n    if ((navBarProps.leftTitle || navBarProps.leftButtonImage) && navBarProps.onLeft) {\n      delete navBarProps.leftButton;\n    }\n\n    if ((navBarProps.rightTitle || navBarProps.rightButtonImage) && navBarProps.onRight) {\n      delete navBarProps.rightButton;\n    }\n\n    if (navBarProps.rightButton) {\n      delete navBarProps.rightTitle;\n      delete navBarProps.onRight;\n      delete navBarProps.rightButtonImage;\n    }\n\n    if (navBarProps.leftButton) {\n      delete navBarProps.leftTitle;\n      delete navBarProps.onLeft;\n      delete navBarProps.leftButtonImage;\n    }\n    delete navBarProps.style;\n\n    const getTitle = selected.getTitle || (opts => opts.title);\n    return <HeaderComponent {...props} {...navBarProps} getTitle={getTitle} />;\n  }\n\n  static renderCard(/* NavigationSceneRendererProps */ props) {\n    const { key,\n      direction,\n      animation,\n      getSceneStyle,\n      getPanHandlers,\n    } = props.scene.navigationState;\n\n    const state = props.navigationState;\n    const child = state.children[state.index];\n    let selected = state.children[state.index];\n    while ({}.hasOwnProperty.call(selected, 'children')) {\n      selected = selected.children[selected.index];\n    }\n    let { panHandlers, animationStyle } = selected;\n    const isActive = child === selected;\n    const computedProps = { isActive };\n    if (isActive) {\n      computedProps.hideNavBar = deepestExplicitValueForKey(props.navigationState, 'hideNavBar');\n      computedProps.hideTabBar = deepestExplicitValueForKey(props.navigationState, 'hideTabBar');\n    }\n\n    const style = getSceneStyle ? getSceneStyle(props, computedProps) : null;\n\n    // direction overrides animation if both are supplied\n    const animType = (animation && !direction) ? animation : direction;\n\n    if (typeof (animationStyle) === 'undefined') {\n      animationStyle = DefaultRenderer.chooseInterpolator(animType, props);\n    }\n\n    if (typeof (animationStyle) === 'function') {\n      animationStyle = animationStyle(props);\n    }\n\n    if (typeof (panHandlers) === 'undefined') {\n      panHandlers = getPanHandlers ?\n        getPanHandlers(props, direction) :\n        DefaultRenderer.getPanHandlers(direction, props);\n    }\n    return (\n      <NavigationCard\n        {...props}\n        key={`card_${key}`}\n        style={[animationStyle, style]}\n        panHandlers={panHandlers}\n        renderScene={DefaultRenderer.renderScene}\n      />\n    );\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.shouldComponentUpdate = PureRenderMixin.shouldComponentUpdate.bind(this);\n  }\n\n  getChildContext() {\n    return {\n      navigationState: this.props.navigationState,\n    };\n  }\n\n  componentDidMount() {\n    DefaultRenderer.dispatchFocusAction(this.props);\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.navigationState !== this.props.navigationState) {\n      DefaultRenderer.dispatchFocusAction(nextProps);\n    }\n  }\n\n  render() {\n    const { navigationState, onNavigate } = this.props;\n\n    if (!navigationState || !onNavigate) {\n      console.error('navigationState and onNavigate property should be not null');\n      return null;\n    }\n\n    let SceneComponent = navigationState.component;\n\n    if (navigationState.tabs && !SceneComponent) {\n      SceneComponent = TabBar;\n    }\n\n    if (SceneComponent) {\n      return (\n        <View\n          style={[styles.sceneStyle, navigationState.sceneStyle]}\n        >\n          <SceneComponent {...this.props} {...navigationState} />\n        </View>\n      );\n    }\n\n    const optionals = {};\n    const selected = navigationState.children[navigationState.index];\n    const applyAnimation = selected.applyAnimation || navigationState.applyAnimation;\n    const style = selected.style || navigationState.style;\n\n    if (applyAnimation) {\n      optionals.applyAnimation = applyAnimation;\n    } else {\n      let duration = selected.duration;\n      if (duration === null || duration === undefined) duration = navigationState.duration;\n      if (duration !== null && duration !== undefined) {\n        optionals.applyAnimation = (pos, navState) => {\n          if (duration === 0) {\n            pos.setValue(navState.index);\n          } else {\n            Animated.timing(pos, { toValue: navState.index, duration }).start();\n          }\n        };\n      }\n    }\n\n    // console.log(`NavigationAnimatedView for ${navigationState.key}`);\n\n    return (\n      <NavigationAnimatedView\n        navigationState={navigationState}\n        style={[styles.animatedView, style]}\n        renderOverlay={DefaultRenderer.renderHeader}\n        renderScene={DefaultRenderer.renderCard}\n        {...optionals}\n      />\n    );\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/Modal.js":"import React, {\n  PropTypes,\n} from 'react';\nimport {\n  View,\n} from 'react-native';\nimport DefaultRenderer from './DefaultRenderer';\n\nconst propTypes = {\n  navigationState: PropTypes.shape({\n    children: PropTypes.array,\n  }),\n  onNavigate: PropTypes.func,\n};\n\nexport default function Modal(props: Object) {\n  const children = props.navigationState.children;\n  const state = children[0];\n\n  return (\n    <View style={{ flex: 1 }}>\n      <DefaultRenderer\n        navigationState={state}\n        key={state.key}\n        {...state}\n        onNavigate={props.onNavigate}\n      />\n      {children.length > 1 && children.map((el, i) => {\n        if (i > 0 && el.component) {\n          const Component = el.component;\n          return (\n            <Component\n              navigationState={children[i]}\n              key={el.key}\n              {...el}\n              onNavigate={props.onNavigate}\n            />\n          );\n        }\n\n        return null;\n      })}\n    </View>\n  );\n}\n\nModal.propTypes = propTypes;\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/NavBar.js":"/**\n * Copyright (c) 2015, Facebook, Inc.  All rights reserved.\n *\n * Facebook, Inc. (\"Facebook\") owns all right, title and interest, including\n * all intellectual property and other proprietary rights, in and to the React\n * Native CustomComponents software (the \"Software\").  Subject to your\n * compliance with these terms, you are hereby granted a non-exclusive,\n * worldwide, royalty-free copyright license to (1) use and copy the Software;\n * and (2) reproduce and distribute the Software as part of your own software\n * (\"Your Software\").  Facebook reserves all rights not expressly granted to\n * you in this license agreement.\n *\n * THE SOFTWARE AND DOCUMENTATION, IF ANY, ARE PROVIDED \"AS IS\" AND ANY EXPRESS\n * OR IMPLIED WARRANTIES (INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE) ARE DISCLAIMED.\n * IN NO EVENT SHALL FACEBOOK OR ITS AFFILIATES, OFFICERS, DIRECTORS OR\n * EMPLOYEES BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;\n * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\nimport React, {\n  PropTypes,\n} from 'react';\nimport {\n  Platform,\n  Animated,\n  Image,\n  StyleSheet,\n  Text,\n  TouchableOpacity,\n  View,\n} from 'react-native';\nimport Actions from './Actions';\nimport _drawerImage from './menu_burger.png';\nimport _backButtonImage from './back_chevron.png';\n\nconst styles = StyleSheet.create({\n  title: {\n    textAlign: 'center',\n    color: '#0A0A0A',\n    fontSize: 18,\n    width: 180,\n    alignSelf: 'center',\n  },\n  titleWrapper: {\n    marginTop: 10,\n    position: 'absolute',\n    ...Platform.select({\n      ios: {\n        top: 20,\n      },\n      android: {\n        top: 5,\n      },\n    }),\n    left: 0,\n    right: 0,\n  },\n  header: {\n    backgroundColor: '#EFEFF2',\n    paddingTop: 0,\n    top: 0,\n    ...Platform.select({\n      ios: {\n        height: 64,\n      },\n      android: {\n        height: 54,\n      },\n    }),\n    right: 0,\n    left: 0,\n    borderBottomWidth: 0.5,\n    borderBottomColor: '#828287',\n    position: 'absolute',\n  },\n  backButton: {\n    height: 37,\n    position: 'absolute',\n    ...Platform.select({\n      ios: {\n        top: 22,\n      },\n      android: {\n        top: 10,\n      },\n    }),\n    left: 2,\n    padding: 8,\n    flexDirection: 'row',\n  },\n  rightButton: {\n    height: 37,\n    position: 'absolute',\n    ...Platform.select({\n      ios: {\n        top: 22,\n      },\n      android: {\n        top: 10,\n      },\n    }),\n    right: 2,\n    padding: 8,\n  },\n  leftButton: {\n    height: 37,\n    position: 'absolute',\n    ...Platform.select({\n      ios: {\n        top: 20,\n      },\n      android: {\n        top: 8,\n      },\n    }),\n    left: 2,\n    padding: 8,\n  },\n  barRightButtonText: {\n    color: 'rgb(0, 122, 255)',\n    textAlign: 'right',\n    fontSize: 17,\n  },\n  barBackButtonText: {\n    color: 'rgb(0, 122, 255)',\n    textAlign: 'left',\n    fontSize: 17,\n    paddingLeft: 6,\n  },\n  barLeftButtonText: {\n    color: 'rgb(0, 122, 255)',\n    textAlign: 'left',\n    fontSize: 17,\n  },\n  backButtonImage: {\n    width: 13,\n    height: 21,\n  },\n  defaultImageStyle: {\n    height: 24,\n    resizeMode: 'contain',\n  },\n});\n\nconst propTypes = {\n  navigationState: PropTypes.object,\n  backButtonImage: Image.propTypes.source,\n  wrapBy: PropTypes.any,\n  component: PropTypes.any,\n  backButtonTextStyle: Text.propTypes.style,\n  leftButtonStyle: View.propTypes.style,\n  leftButtonIconStyle: Image.propTypes.style,\n  getTitle: PropTypes.func,\n  titleWrapperStyle: Text.propTypes.style,\n  titleStyle: Text.propTypes.style,\n  titleOpacity: PropTypes.number,\n  titleProps: PropTypes.any,\n  position: PropTypes.object,\n  navigationBarStyle: View.propTypes.style,\n  navigationBarBackgroundImage: Image.propTypes.source,\n  renderTitle: PropTypes.any,\n};\n\nconst contextTypes = {\n  drawer: PropTypes.object,\n};\n\nconst defaultProps = {\n  drawerImage: _drawerImage,\n  backButtonImage: _backButtonImage,\n  titleOpacity: 1,\n};\n\nclass NavBar extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this.renderRightButton = this.renderRightButton.bind(this);\n    this.renderBackButton = this.renderBackButton.bind(this);\n    this.renderLeftButton = this.renderLeftButton.bind(this);\n    this.renderTitle = this.renderTitle.bind(this);\n  }\n\n  renderBackButton() {\n    const state = this.props.navigationState;\n    const childState = state.children[state.index];\n    const BackButton = (childState.component && childState.component.backButton) || state.backButton\n      || childState.backButton;\n    const textButtonStyle = [\n      styles.barBackButtonText,\n      this.props.backButtonTextStyle,\n      state.backButtonTextStyle,\n      childState.backButtonTextStyle,\n    ];\n    const style = [\n      styles.backButton,\n      this.props.leftButtonStyle,\n      state.leftButtonStyle,\n      childState.leftButtonStyle,\n    ];\n\n    if (state.index === 0 && (!state.parentIndex || state.parentIndex === 0)) {\n      return null;\n    }\n\n    if (BackButton) {\n      return (\n        <BackButton\n          testID=\"backNavButton\"\n          textButtonStyle={textButtonStyle}\n          {...childState}\n          style={style}\n        />\n      );\n    }\n    const buttonImage = childState.backButtonImage ||\n      state.backButtonImage || this.props.backButtonImage;\n    let onPress = childState.onBack || childState.component.onBack;\n    if (onPress) {\n      onPress = onPress.bind(null, state);\n    } else {\n      onPress = Actions.pop;\n    }\n\n    const text = childState.backTitle ?\n      (<Text style={textButtonStyle}>\n        {childState.backTitle}\n      </Text>)\n      : null;\n\n    return (\n      <TouchableOpacity\n        testID=\"backNavButton\"\n        style={style}\n        onPress={onPress}\n      >\n        {buttonImage && !childState.hideBackImage &&\n          <Image\n            source={buttonImage}\n            style={[\n              styles.backButtonImage,\n              this.props.leftButtonIconStyle,\n              state.barButtonIconStyle,\n              state.leftButtonIconStyle,\n              childState.leftButtonIconStyle,\n            ]}\n          />\n        }\n        {text}\n      </TouchableOpacity>\n    );\n  }\n\n  renderRightButton(navProps) {\n    const self = this;\n    function tryRender(state, wrapBy) {\n      if (!state) {\n        return null;\n      }\n      const rightTitle = state.getRightTitle ? state.getRightTitle(navProps) : state.rightTitle;\n\n      const textStyle = [styles.barRightButtonText, self.props.rightButtonTextStyle,\n        state.rightButtonTextStyle];\n      const style = [styles.rightButton, self.props.rightButtonStyle, state.rightButtonStyle];\n      if (state.rightButton) {\n        let Button = state.rightButton;\n        if (wrapBy) {\n          Button = wrapBy(Button);\n        }\n        return (\n          <Button\n            {...self.props}\n            {...state}\n            key={'rightNavBarBtn'}\n            testID=\"rightNavButton\"\n            style={style}\n            textButtonStyle={textStyle}\n          />\n        );\n      }\n      if (state.onRight && (rightTitle || state.rightButtonImage)) {\n        const onPress = state.onRight.bind(null, state);\n        return (\n          <TouchableOpacity\n            key={'rightNavBarBtn'}\n            testID=\"rightNavButton\"\n            style={style}\n            onPress={onPress}\n          >\n            {rightTitle &&\n              <Text style={textStyle}>\n                {rightTitle}\n              </Text>\n            }\n            {state.rightButtonImage &&\n              <View style={{ flex: 1, justifyContent: 'center', alignItems: 'flex-end' }}>\n                <Image\n                  source={state.rightButtonImage}\n                  style={state.rightButtonIconStyle}\n                />\n              </View>\n            }\n          </TouchableOpacity>\n        );\n      }\n      if ((!!state.onRight ^ !!(typeof (rightTitle) !== 'undefined'\n        || typeof (state.rightButtonImage) !== 'undefined'))) {\n        console.warn(\n          `Both onRight and rightTitle/rightButtonImage\n            must be specified for the scene: ${state.name}`,\n        );\n      }\n      return null;\n    }\n    return tryRender(this.props.component, this.props.wrapBy) || tryRender(this.props);\n  }\n\n  renderLeftButton(navProps) {\n    const self = this;\n    const drawer = this.context.drawer;\n    function tryRender(state, wrapBy) {\n      let onPress = state.onLeft;\n      let buttonImage = state.leftButtonImage;\n      let menuIcon = state.drawerIcon;\n      const style = [styles.leftButton, self.props.leftButtonStyle, state.leftButtonStyle];\n      const textStyle = [styles.barLeftButtonText, self.props.leftButtonTextStyle,\n        state.leftButtonTextStyle];\n      const leftButtonStyle = [styles.defaultImageStyle, state.leftButtonIconStyle];\n      const leftTitle = state.getLeftTitle ? state.getLeftTitle(navProps) : state.leftTitle;\n\n      if (state.leftButton) {\n        let Button = state.leftButton;\n        if (wrapBy) {\n          Button = wrapBy(Button);\n        }\n        return (\n          <Button\n            {...self.props}\n            {...state}\n            key={'leftNavBarBtn'}\n            testID=\"leftNavButton\"\n            style={style}\n            textStyle={textStyle}\n          />\n        );\n      }\n\n      if (!onPress && !!drawer && typeof drawer.toggle === 'function') {\n        buttonImage = state.drawerImage;\n        if (buttonImage || menuIcon) {\n          onPress = drawer.toggle;\n        }\n        if (!menuIcon) {\n          menuIcon = (\n            <Image\n              source={buttonImage}\n              style={leftButtonStyle}\n            />\n          );\n        }\n      }\n\n      if (onPress && (leftTitle || buttonImage)) {\n        onPress = onPress.bind(null, state);\n        return (\n          <TouchableOpacity\n            key={'leftNavBarBtn'}\n            testID=\"leftNavButton\"\n            style={style}\n            onPress={onPress}\n          >\n            {leftTitle &&\n              <Text style={textStyle}>\n                {leftTitle}\n              </Text>\n            }\n            {buttonImage &&\n              <View style={{ flex: 1, justifyContent: 'center', alignItems: 'flex-start' }}>\n                {menuIcon || <Image\n                  source={buttonImage}\n                  style={state.leftButtonIconStyle || styles.defaultImageStyle}\n                />\n                }\n              </View>\n            }\n          </TouchableOpacity>\n        );\n      }\n      if ((!!state.onLeft ^ !!(leftTitle || buttonImage))) {\n        console.warn(\n          `Both onLeft and leftTitle/leftButtonImage\n            must be specified for the scene: ${state.name}`,\n        );\n      }\n      return null;\n    }\n    return tryRender(this.props.component, this.props.wrapBy) || tryRender(this.props);\n  }\n\n  renderTitle(childState, index:number) {\n    let title = this.props.getTitle ? this.props.getTitle(childState) : childState.title;\n    if (title === undefined && childState.component && childState.component.title) {\n      title = childState.component.title;\n    }\n    if (typeof (title) === 'function') {\n      title = title(childState);\n    }\n    return (\n      <Animated.View\n        key={childState.key}\n        style={[\n          styles.titleWrapper,\n          this.props.titleWrapperStyle,\n        ]}\n      >\n        <Animated.Text\n          lineBreakMode=\"tail\"\n          numberOfLines={1}\n          {...this.props.titleProps}\n          style={[\n            styles.title,\n            this.props.titleStyle,\n            this.props.navigationState.titleStyle,\n            childState.titleStyle,\n            {\n              opacity: this.props.position.interpolate({\n                inputRange: [index - 1, index, index + 1],\n                outputRange: [0, this.props.titleOpacity, 0],\n              }),\n              left: this.props.position.interpolate({\n                inputRange: [index - 1, index + 1],\n                outputRange: [200, -200],\n              }),\n              right: this.props.position.interpolate({\n                inputRange: [index - 1, index + 1],\n                outputRange: [-200, 200],\n              }),\n            },\n          ]}\n        >\n          {title}\n        </Animated.Text>\n      </Animated.View>\n    );\n  }\n\n  render() {\n    let state = this.props.navigationState;\n    let selected = state.children[state.index];\n    while ({}.hasOwnProperty.call(selected, 'children')) {\n      state = selected;\n      selected = selected.children[selected.index];\n    }\n    const navProps = { ...this.props, ...selected };\n\n    const wrapByStyle = (component, wrapStyle) => {\n      if (!component) { return null; }\n      return props => <View style={wrapStyle}>{component(props)}</View>;\n    };\n\n    const leftButtonStyle = [styles.leftButton, { alignItems: 'flex-start' }];\n    const rightButtonStyle = [styles.rightButton, { alignItems: 'flex-end' }];\n\n    const renderLeftButton = wrapByStyle(selected.renderLeftButton, leftButtonStyle) ||\n      wrapByStyle(selected.component.renderLeftButton, leftButtonStyle) ||\n      this.renderLeftButton;\n    const renderRightButton = wrapByStyle(selected.renderRightButton, rightButtonStyle) ||\n      wrapByStyle(selected.component.renderRightButton, rightButtonStyle) ||\n      this.renderRightButton;\n    const renderBackButton = wrapByStyle(selected.renderBackButton, leftButtonStyle) ||\n      wrapByStyle(selected.component.renderBackButton, leftButtonStyle) ||\n      this.renderBackButton;\n    const renderTitle = selected.renderTitle ||\n      selected.component.renderTitle ||\n      this.props.renderTitle;\n    const navigationBarBackgroundImage = this.props.navigationBarBackgroundImage ||\n      state.navigationBarBackgroundImage;\n    const contents = (\n      <View>\n        {renderTitle ? renderTitle(navProps) : state.children.map(this.renderTitle, this)}\n        {renderBackButton(navProps) || renderLeftButton(navProps)}\n        {renderRightButton(navProps)}\n      </View>\n    );\n    return (\n      <Animated.View\n        style={[\n          styles.header,\n          this.props.navigationBarStyle,\n          state.navigationBarStyle,\n          selected.navigationBarStyle,\n        ]}\n      >\n        {navigationBarBackgroundImage ? (\n          <Image source={navigationBarBackgroundImage}>\n            {contents}\n          </Image>\n        ) : contents}\n      </Animated.View>\n    );\n  }\n}\n\nNavBar.propTypes = propTypes;\nNavBar.contextTypes = contextTypes;\nNavBar.defaultProps = defaultProps;\n\nexport default NavBar;\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/Reducer.js":"/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/* eslint-disable no-param-reassign */\n\nimport { Platform } from 'react-native';\nimport * as ActionConst from './ActionConst';\nimport { ActionMap } from './Actions';\nimport { assert } from './Util';\nimport { getInitialState } from './State';\n\n// WARN: it is not working correct. rewrite it.\nfunction checkPropertiesEqual(action, lastAction) {\n  let isEqual = true;\n  for (const key of Object.keys(action)) {\n    if (['key', 'type', 'parent'].indexOf(key) === -1) {\n      if (action[key] !== lastAction[key]) {\n        isEqual = false;\n      }\n    }\n  }\n  return isEqual;\n}\n\nfunction resetHistoryStack(child) {\n  const newChild = child;\n  newChild.index = 0;\n  child.children.map(\n    (el, i) => {\n      if (el.initial) {\n        newChild.index = i;\n        if (!newChild.tabs) {\n          newChild.children = [el];\n        }\n      }\n      if (el.children) {\n        resetHistoryStack(el);\n      }\n      return newChild;\n    },\n  );\n}\n\nfunction refreshTopChild(children, refresh) {\n  if (refresh) {\n    const topChild = children[children.length - 1];\n    return [...children.slice(0, -1), { ...topChild, ...refresh }];\n  }\n  return children;\n}\n\nfunction inject(state, action, props, scenes) {\n  const condition = ActionMap[action.type] === ActionConst.REFRESH ? state.key === props.key ||\n  state.sceneKey === action.key : state.sceneKey === props.parent;\n  // console.log(\"INJECT:\", action.key, state.sceneKey, condition);\n  if (!condition) {\n    if (state.children) {\n      const res = state.children.map(el => inject(el, action, props, scenes));\n      let changed = false;\n      let changedIndex = -1;\n      for (let i = 0; i < res.length; i += 1) {\n        if (res[i] !== state.children[i]) {\n          changed = true;\n          changedIndex = i;\n          break;\n        }\n      }\n      return changed ? { ...state, children: res, index: changedIndex } : state;\n    }\n    return state;\n  }\n  let ind;\n\n  switch (ActionMap[action.type]) {\n    case ActionConst.POP_TO: {\n      const targetIndex = action.targetIndex;\n\n      return {\n        ...state,\n        index: targetIndex,\n        children: refreshTopChild(state.children.slice(0, (targetIndex + 1)), action.refresh),\n      };\n    }\n\n    case ActionConst.BACK:\n    case ActionConst.BACK_ACTION: {\n      assert(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n\n      if (state.index === 0) {\n        return state;\n      }\n\n      let popNum = 1;\n      if (action.popNum) {\n        assert(typeof (action.popNum) === 'number',\n          'The data is the number of scenes you want to pop, it must be Number');\n        popNum = action.popNum;\n        assert(popNum % 1 === 0,\n          'The data is the number of scenes you want to pop, it must be integer.');\n        assert(popNum > 1,\n          'The data is the number of scenes you want to pop, it must be bigger than 1.');\n        assert(popNum <= state.index,\n          'The data is the number of scenes you want to pop, ' +\n          \"it must be smaller than scenes stack's length.\");\n      }\n\n      return {\n        ...state,\n        index: state.index - popNum,\n        from: state.children[state.children.length - popNum],\n        children: refreshTopChild(state.children.slice(0, -1 * popNum), action.refresh),\n      };\n    }\n    case ActionConst.ANDROID_BACK: {\n      if (Platform.OS === 'android') {\n        assert(state.index > 0, 'You are already in the root scene.');\n      }\n\n      return {\n        ...state,\n        index: state.index - 1,\n        from: state.children[state.children.length - 1],\n        children: refreshTopChild(state.children.slice(0, -1), action.refresh),\n      };\n    }\n    // This action will pop the scene stack and then replace current scene in one go\n    case ActionConst.POP_AND_REPLACE: {\n      assert(!state.tabs, 'pop() operation cannot be run on tab bar (tabs=true)');\n      assert(state.index > 0, 'You are already in the root scene.');\n\n      let popNum = 1;\n      if (action.popNum) {\n        assert(typeof (action.popNum) === 'number',\n          'The data is the number of scenes you want to pop, it must be Number');\n        popNum = action.popNum;\n        assert(popNum % 1 === 0,\n          'The data is the number of scenes you want to pop, it must be integer.');\n        assert(popNum > 1,\n          'The data is the number of scenes you want to pop, it must be bigger than 1.');\n        assert(popNum <= state.index,\n          'The data is the number of scenes you want to pop, ' +\n          \"it must be smaller than scenes stack's length.\");\n      }\n\n      state = {\n        ...state,\n        index: state.index - popNum,\n        from: state.children[state.children.length - popNum],\n        children: state.children.slice(0, -1 * popNum),\n      };\n\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      const newAction = {\n        duration: 0,  // do not animate\n        ...action,\n      };\n      delete newAction.popNum;\n\n      const newProps = { ...props };\n      delete newProps.popNum;\n\n      state.children[state.children.length - 1] = getInitialState(\n        newProps,\n        scenes,\n        state.index,\n        newAction,\n      );\n\n      return { ...state, children: state.children };\n    }\n    case ActionConst.REFRESH:\n      return props.base ? {\n        navBar: state.navBar,\n        ...scenes.rootProps,\n        ...props,\n        key: state.key,\n        from: null }\n      : {\n        ...state,\n        ...props,\n        key: state.key,\n        from: null,\n      };\n    case ActionConst.PUSH_OR_POP:\n      ind = state.children.findIndex(el => el.sceneKey === action.key);\n      if (ind !== -1) {\n        return {\n          ...state,\n          index: ind,\n          from: state.children[state.index],\n          children: refreshTopChild(state.children.slice(0, ind + 1), action.refresh),\n        };\n      }\n      return {\n        ...state,\n        index: state.index + 1,\n        from: null,\n        children: [...state.children, getInitialState(props, scenes, state.index + 1, action)],\n      };\n    case ActionConst.PUSH:\n      if (state.children[state.index].sceneKey === action.key && !props.clone\n        && checkPropertiesEqual(action, state.children[state.index])) {\n        return state;\n      }\n      return {\n        ...state,\n        index: state.index + 1,\n        from: null,\n        children: [...state.children, getInitialState(props, scenes, state.index + 1, action)],\n      };\n    case ActionConst.JUMP: {\n      assert(state.tabs, `Parent=${state.key} is not tab bar, jump action is not valid`);\n      ind = -1;\n      state.children.forEach((c, i) => { if (c.sceneKey === action.key) { ind = i; } });\n      assert(ind !== -1, `Cannot find route with key=${action.key} for parent=${state.key}`);\n\n      if (action.unmountScenes) {\n        resetHistoryStack(state.children[ind]);\n      }\n\n      state.children[ind] = getInitialState(\n        props,\n        scenes,\n        state.index,\n        action,\n      );\n\n      return { ...state, index: ind };\n    }\n    case ActionConst.REPLACE:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children[state.children.length - 1] = getInitialState(\n        props,\n        scenes,\n        state.index,\n        action,\n      );\n\n      return { ...state, children: state.children };\n    case ActionConst.RESET:\n      if (state.children[state.index].sceneKey === action.key) {\n        return state;\n      }\n\n      state.children = state.children.splice(0, 1);\n      state.children[0] = getInitialState(props, scenes, state.index, action);\n\n      return {\n        ...state,\n        index: 0,\n        from: null,\n        children: state.children,\n      };\n    default:\n      return state;\n  }\n}\n\nexport function findElement(state, key, type) {\n  if ((ActionMap[type] === ActionConst.REFRESH && state.key === key) || state.sceneKey === key) {\n    return state;\n  }\n  if (state.children) {\n    for (const child of state.children) {\n      const current = findElement(child, key, type);\n      if (current) return current;\n    }\n  }\n  return null;\n}\n\nexport function getCurrent(state) {\n  if (!state.children) {\n    return state;\n  }\n  return getCurrent(state.children[state.index]);\n}\n\nfunction update(state, action) {\n  // find parent in the state\n  const props = { ...state.scenes[action.key], ...action };\n  assert(props.parent, `No parent is defined for route=${action.key}`);\n  return inject(state, action, props, state.scenes);\n}\n\nfunction reducer({ initialState, scenes }) {\n  assert(initialState, 'initialState should not be null');\n  assert(initialState.key, 'initialState.key should not be null');\n  assert(scenes, 'scenes should not be null');\n  return (stateParam, actionParam) => {\n    let state = stateParam;\n    let action = actionParam;\n    state = state || { ...initialState, scenes };\n    assert(action, 'action should be defined');\n    assert(action.type, 'action type should be defined');\n    assert(state.scenes, 'state.scenes is missed');\n\n    if (action.key) {\n      if (ActionMap[action.type] === ActionConst.REFRESH) {\n        let key = action.key;\n        let child = findElement(state, key, action.type) || state.scenes[key];\n        let sceneKey = child.sceneKey;\n        if (child.base) {\n          child = { ...state.scenes[child.base], ...child };\n          assert(state.scenes[child.base], `No scene exists for base=${child.base}`);\n          key = state.scenes[child.base].key;\n          sceneKey = state.scenes[child.base].sceneKey;\n        }\n        assert(child, `missed child data for key=${key}`);\n        // evaluate functions within actions to allow conditional set, like switch values\n        const evaluated = {};\n        Object.keys(action).forEach((el) => {\n          if (typeof action[el] === 'function' && typeof child[el] !== 'undefined'\n            && typeof child[el] !== typeof action[el]) {\n            evaluated[el] = action[el](child[el], child);\n          }\n        });\n        action = { ...child, ...action, ...evaluated, sceneKey, key };\n\n        // console.log(\"REFRESH ACTION:\", action);\n      } else {\n        const scene = state.scenes[action.key];\n        assert(scene, `missed route data for key=${action.key}`);\n        // clone scene\n        if (scene.clone) {\n          action.parent = getCurrent(state).parent;\n        }\n      }\n    } else {\n      // set current route for pop action or refresh action\n      if (ActionMap[action.type] === ActionConst.BACK_ACTION ||\n          ActionMap[action.type] === ActionConst.BACK ||\n          ActionMap[action.type] === ActionConst.ANDROID_BACK ||\n          ActionMap[action.type] === ActionConst.POP_AND_REPLACE ||\n          ActionMap[action.type] === ActionConst.REFRESH ||\n          ActionMap[action.type] === ActionConst.POP_TO) {\n        if (!action.key && !action.parent) {\n          action = { ...getCurrent(state), ...action };\n        }\n      }\n\n      // Find the parent and index of the future state\n      if (ActionMap[action.type] === ActionConst.POP_TO) {\n        /*\n         * if a string is passed as only argument\n         * Actions.filterParam will put it in the data property\n         * otherwise look for the scene property\n         */\n        const target = action.data || action.scene;\n        assert(target, 'PopTo() must be called with a single argument: ' +\n        'either the scene name (string) or an object with within the scene property ' +\n        'carrying the target scene to pop to');\n\n        const targetEl = findElement(state, target, action.type);\n        assert(targetEl, `Cannot find element name named ${target} within current state`);\n\n        // target is a node\n        let parent = targetEl.sceneKey;\n        let targetIndex = 0;\n\n        // target is child of a node\n        if (!targetEl.children) {\n          const targetParent = findElement(state, targetEl.parent, action.type);\n          assert(targetParent, `Cannot find parent for target ${target}`);\n          parent = targetParent.sceneKey;\n\n          targetIndex = targetParent.children.indexOf(targetEl);\n          assert(targetIndex > -1, `${target} does not belong to ${targetParent.sceneKey}`);\n        }\n\n        action.parent = parent;\n        action.targetIndex = targetIndex;\n      }\n\n      // recursive pop parent\n      if (ActionMap[action.type] === ActionConst.BACK_ACTION ||\n          ActionMap[action.type] === ActionConst.BACK ||\n          ActionMap[action.type] === ActionConst.ANDROID_BACK ||\n          ActionMap[action.type] === ActionConst.POP_AND_REPLACE) {\n        const parent = action.parent || state.scenes[action.key].parent;\n        let el = findElement(state, parent, action.type);\n        while (el.parent && (el.children.length <= 1 || el.tabs)) {\n          el = findElement(state, el.parent, action.type);\n          assert(el, `Cannot find element for parent=${el.parent} within current state`);\n        }\n        action.parent = el.sceneKey;\n      }\n    }\n\n    switch (ActionMap[action.type]) {\n      case ActionConst.BACK:\n      case ActionConst.BACK_ACTION:\n      case ActionConst.POP_AND_REPLACE:\n      case ActionConst.POP_TO:\n      case ActionConst.REFRESH:\n      case ActionConst.PUSH:\n      case ActionConst.PUSH_OR_POP:\n      case ActionConst.JUMP:\n      case ActionConst.REPLACE:\n      case ActionConst.RESET:\n      case ActionConst.ANDROID_BACK:\n        return update(state, action);\n\n      default:\n        return state;\n\n    }\n  };\n}\n\nexport default reducer;\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/Router.js":"/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport React, {\n  Component,\n  PropTypes,\n} from 'react';\nimport { BackAndroid } from 'react-native';\nimport NavigationExperimental from 'react-native-experimental-navigation';\n\nimport Actions, { ActionMap } from './Actions';\nimport getInitialStateFromRoot from './State';\nimport Reducer, { findElement } from './Reducer';\nimport DefaultRenderer from './DefaultRenderer';\nimport Scene from './Scene';\nimport * as ActionConst from './ActionConst';\n\nconst {\n  RootContainer: NavigationRootContainer,\n} = NavigationExperimental;\n\nconst propTypes = {\n  dispatch: PropTypes.func,\n  backAndroidHandler: PropTypes.func,\n  onBackAndroid: PropTypes.func,\n  onExitApp: PropTypes.func,\n};\n\nclass Router extends Component {\n  static childContextTypes = {\n    routes: PropTypes.object,\n  }\n\n  constructor(props) {\n    super(props);\n    this.renderNavigation = this.renderNavigation.bind(this);\n    this.handleProps = this.handleProps.bind(this);\n    this.handleBackAndroid = this.handleBackAndroid.bind(this);\n    const reducer = this.handleProps(props);\n    this.state = { reducer };\n  }\n\n  getChildContext() {\n    return {\n      routes: Actions,\n    };\n  }\n\n  componentDidMount() {\n    BackAndroid.addEventListener('hardwareBackPress', this.handleBackAndroid);\n  }\n\n  componentWillReceiveProps(props) {\n    const reducer = this.handleProps(props);\n    this.setState({ reducer });\n  }\n\n  componentWillUnmount() {\n    BackAndroid.removeEventListener('hardwareBackPress', this.handleBackAndroid);\n  }\n\n  handleBackAndroid() {\n    const {\n      backAndroidHandler,\n      onBackAndroid,\n      onExitApp,\n    } = this.props;\n    // optional for customizing handler\n    if (backAndroidHandler) {\n      return backAndroidHandler();\n    }\n\n    try {\n      Actions.androidBack();\n      if (onBackAndroid) {\n        onBackAndroid();\n      }\n      return true;\n    } catch (err) {\n      if (onExitApp) {\n        return onExitApp();\n      }\n\n      return false;\n    }\n  }\n\n  handleProps(props) {\n    let scenesMap;\n\n    if (props.scenes) {\n      scenesMap = props.scenes;\n    } else {\n      let scenes = props.children;\n\n      if (Array.isArray(props.children) || props.children.props.component) {\n        scenes = (\n          <Scene\n            key=\"__root\"\n            hideNav\n            {...this.props}\n          >\n            {props.children}\n          </Scene>\n        );\n      }\n      scenesMap = Actions.create(scenes, props.wrapBy);\n    }\n\n    // eslint-disable-next-line no-unused-vars\n    const { children, styles, scenes, reducer, createReducer, ...parentProps } = props;\n\n    scenesMap.rootProps = parentProps;\n\n    const initialState = getInitialStateFromRoot(scenesMap);\n    const reducerCreator = props.createReducer || Reducer;\n\n    const routerReducer = props.reducer || (\n      reducerCreator({\n        initialState,\n        scenes: scenesMap,\n      }));\n\n    return routerReducer;\n  }\n\n  renderNavigation(navigationState, onNavigate) {\n    if (!navigationState) {\n      return null;\n    }\n    Actions.get = key => findElement(navigationState, key, ActionConst.REFRESH);\n    Actions.callback = (props) => {\n      const constAction = (props.type && ActionMap[props.type] ? ActionMap[props.type] : null);\n      if (this.props.dispatch) {\n        if (constAction) {\n          this.props.dispatch({ ...props, type: constAction });\n        } else {\n          this.props.dispatch(props);\n        }\n      }\n      return (constAction ? onNavigate({ ...props, type: constAction }) : onNavigate(props));\n    };\n\n    return <DefaultRenderer onNavigate={onNavigate} navigationState={navigationState} />;\n  }\n\n  render() {\n    if (!this.state.reducer) return null;\n\n    return (\n      <NavigationRootContainer\n        reducer={this.state.reducer}\n        renderNavigation={this.renderNavigation}\n      />\n    );\n  }\n}\n\nRouter.propTypes = propTypes;\n\nexport default Router;\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/Scene.js":"/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport React, { PropTypes } from 'react';\nimport { View, Text } from 'react-native';\n\nexport default class extends React.Component {\n\n  // @todo - should all props be documented/specified here?\n\n  static propTypes = {\n    tabBarStyle: View.propTypes.style,\n    tabBarSelectedItemStyle: View.propTypes.style,\n    tabBarIconContainerStyle: View.propTypes.style,\n    tabBarShadowStyle: View.propTypes.style,\n    tabSceneStyle: View.propTypes.style,\n    tabStyle: View.propTypes.style,\n    tabTitleStyle: Text.propTypes.style,\n    tabSelectedTitleStyle: Text.propTypes.style,\n    tabTitle: PropTypes.string,\n  };\n\n  render() {\n    return null;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/State.js":"/**\n * Copyright (c) 2015-present, Pavel Aksonov\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nimport { assert } from './Util';\nimport * as ActionConst from './ActionConst';\n\nfunction getStateFromScenes(route, scenes, props) {\n  const getters = [];\n  let result = {};\n  let scene = route;\n  while (scene) {\n    if (scene.getInitialState) {\n      getters.push(scene.getInitialState);\n    }\n    scene = scenes[scene.parent];\n  }\n\n  if (scenes.rootProps && scenes.rootProps.getInitialState) {\n    getters.push(scenes.rootProps.getInitialState);\n  }\n\n  getters.reverse().forEach((fn) => {\n    result = { ...result, ...fn(props) };\n  });\n\n  return result;\n}\n\nfunction getSceneKey(parent, key, position, sceneKey) {\n  return [parent, key, position, sceneKey]\n    .filter(v => typeof (v) !== 'undefined' && v !== null)\n    .join('_');\n}\n\nexport function getInitialState(\n  route: {string: any},\n  scenes: {string: any},\n  position = 0,\n  props = {},\n) {\n  // eslint-disable-next-line no-unused-vars\n  const { parent, key, style, type, ...parentProps } = props;\n  if (!route.children) {\n    return {\n      ...scenes.rootProps,\n      ...route,\n      key: getSceneKey(parent, key, position, route.sceneKey),\n      ...parentProps,\n      ...getStateFromScenes(route, scenes, props),\n    };\n  }\n  const res = { ...route, ...scenes.rootProps, ...parentProps };\n  let index = 0;\n  route.children.forEach((r, i) => {\n    assert(scenes[r], `Empty scene for key=${route.key}`);\n    if (scenes[r].initial) {\n      index = i;\n    }\n  });\n\n  if (route.tabs) {\n    res.children = route.children.map(\n      (r, i) => getInitialState(scenes[r], scenes, i, { ...props, parentIndex: position }));\n    res.index = index;\n  } else {\n    res.children = [getInitialState(scenes[route.children[index]], scenes, 0, props)];\n    res.index = 0;\n  }\n\n  // Copy props to the children of tab routes\n  if (route.type === ActionConst.JUMP) {\n    res.children = res.children.map(child => ({ ...props, ...child }));\n  }\n\n  res.key = `${position}_${res.key}`;\n  return res;\n}\n\nexport default function (scenes:{string: any}) {\n  // find \"root\" component and get state from it\n  const rootRoute = Object.keys(scenes).find(route =>\n    ({}).hasOwnProperty.call(scenes, route) && !scenes[route].parent);\n\n  return getInitialState(scenes[rootRoute], scenes);\n}\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/Switch.js":"import React, { PropTypes } from 'react';\nimport TabBar from './TabBar';\nimport Actions from './Actions';\n\nexport default function Switch(props) {\n  const navState = props.navigationState;\n\n  const selector = props.selector;\n  const statem = props.statem;\n  if (!selector && !statem) console.error('Selector should be defined.');\n  let index = -1;\n  let selectedKey;\n  if (!selector) {\n    // support Statem - Harel statecharts machine!\n    navState.children.forEach((el, i) => {\n      if (!(el.default || el.state)) {\n        console.error(`Either default or state should be defined for element=${el.key}`);\n      }\n      if (el.default) {\n        index = i;\n      } else if (el.state.active) {\n        index = i;\n      }\n    });\n  } else {\n    selectedKey = selector(props);\n    if (!selectedKey) console.error('Selector should return key.');\n    navState.children.forEach((el, i) => {\n      if (el.sceneKey === selectedKey) {\n        index = i;\n      }\n    });\n  }\n  if (index === -1) console.error(`A scene for key ${selectedKey} does not exist.`);\n  selectedKey = navState.children[index].sceneKey;\n\n  let navigationState;\n  if (index !== navState.index) {\n    if (props.unmountScenes) {\n      navigationState = {\n        ...navState,\n        children: [navState.children[navState.index]],\n        index: 0,\n      };\n      setTimeout(() => {\n        Actions[selectedKey]({ unmountScenes: true });\n      }, 1);\n    } else {\n      navigationState = { ...navState, index };\n      setTimeout(() => {\n        Actions[selectedKey]();\n      }, 1);\n    }\n  } else {\n    navigationState = navState;\n  }\n\n  return (\n    <TabBar\n      onNavigate={props.onNavigate}\n      navigationState={navigationState}\n    />\n  );\n}\n\nSwitch.propTypes = {\n  navigationState: PropTypes.object,\n  onNavigate: PropTypes.func,\n  selector: PropTypes.func,\n  statem: PropTypes.any,\n  unmountScenes: PropTypes.bool,\n};\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/TabBar.js":"import React, { Component, PropTypes } from 'react';\nimport {\n  Image,\n  View,\n} from 'react-native';\nimport Tabs from 'react-native-tabs';\nimport DefaultRenderer from './DefaultRenderer';\nimport Actions from './Actions';\nimport TabbedView from './TabbedView';\nimport { deepestExplicitValueForKey } from './Util';\n\nclass TabBar extends Component {\n\n  static propTypes = {\n    navigationState: PropTypes.object,\n    tabIcon: PropTypes.any,\n    onNavigate: PropTypes.func,\n    unmountScenes: PropTypes.bool,\n    pressOpacity: PropTypes.number,\n    hideOnChildTabs: PropTypes.bool,\n  };\n\n  static onSelect(el) {\n    if (!Actions[el.props.name]) {\n      throw new Error(\n        `No action is defined for name=${el.props.name} ` +\n        `actions: ${JSON.stringify(Object.keys(Actions))}`);\n    }\n    if (typeof el.props.onPress === 'function') {\n      el.props.onPress();\n    } else {\n      Actions[el.props.name]();\n    }\n  }\n\n  constructor(props, context) {\n    super(props, context);\n    this.renderScene = this.renderScene.bind(this);\n  }\n\n  renderScene(navigationState) {\n    return (\n      <DefaultRenderer\n        key={navigationState.key}\n        onNavigate={this.props.onNavigate}\n        navigationState={navigationState}\n      />\n    );\n  }\n\n  render() {\n    const state = this.props.navigationState;\n    const selected = state.children[state.index];\n\n    const hideTabBar = this.props.unmountScenes ||\n      deepestExplicitValueForKey(state, 'hideTabBar') ||\n      (this.props.hideOnChildTabs && deepestExplicitValueForKey(selected, 'tabs'));\n\n    const contents = (\n      <Tabs\n        style={state.tabBarStyle}\n        selectedIconStyle={state.tabBarSelectedItemStyle}\n        iconStyle={state.tabBarIconContainerStyle}\n        onSelect={TabBar.onSelect} {...state}\n        selected={selected.sceneKey}\n        pressOpacity={this.props.pressOpacity}\n      >\n        {state.children.filter(el => el.icon || this.props.tabIcon).map((el) => {\n          const Icon = el.icon || this.props.tabIcon;\n          return <Icon {...this.props} {...el} />;\n        })}\n      </Tabs>\n    );\n    return (\n      <View\n        style={{ flex: 1 }}\n      >\n        <TabbedView\n          navigationState={this.props.navigationState}\n          style={{ flex: 1 }}\n          renderScene={this.renderScene}\n        />\n        {!hideTabBar && state.children.filter(el => el.icon).length > 0 &&\n          (state.tabBarBackgroundImage ? (\n            <Image source={state.tabBarBackgroundImage}>\n              {contents}\n            </Image>\n          ) : contents)\n        }\n      </View>\n    );\n  }\n\n}\n\nexport default TabBar;\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/TabbedView.js":"import React, { Component, PropTypes } from 'react';\nimport { View, StyleSheet } from 'react-native';\nimport StaticContainer from 'react-static-container';\n\nconst styles = StyleSheet.create({\n  scene: {\n    bottom: 0,\n    left: 0,\n    position: 'absolute',\n    right: 0,\n    top: 0,\n  },\n});\n\nclass TabbedView extends Component {\n\n  static propTypes = {\n    navigationState: PropTypes.object.isRequired,\n    renderScene: PropTypes.func.isRequired,\n    style: View.propTypes.style,\n  };\n\n  constructor(props, context) {\n    super(props, context);\n    this.renderedSceneKeys = {};\n    this.renderScene = this.renderScene.bind(this);\n  }\n\n  renderScene(navigationState, index) {\n    const isSelected = index === this.props.navigationState.index;\n    return (\n      <View\n        key={navigationState.key}\n        pointerEvents={isSelected ? 'auto' : 'none'}\n        removeClippedSubviews={!isSelected}\n        style={[\n          styles.scene,\n          { opacity: isSelected ? 1 : 0 },\n        ]}\n      >\n        <StaticContainer shouldUpdate={isSelected}>\n          {this.props.renderScene(navigationState, index)}\n        </StaticContainer>\n      </View>\n    );\n  }\n\n  render() {\n    const scenes = [];\n    const { index, children } = this.props.navigationState;\n    children.forEach((item, i) => {\n      const key = item.key;\n      if (i !== index && !this.renderedSceneKeys[key]) {\n        return;\n      }\n      this.renderedSceneKeys[key] = true;\n      scenes.push(this.renderScene(item, i));\n    });\n    return (\n      <View style={this.props.style}>\n        {scenes}\n      </View>\n    );\n  }\n\n}\n\nexport default TabbedView;\n","/home/travis/build/npmtest/node-npmtest-react-native-router-flux/node_modules/react-native-router-flux/src/Util.js":"// searches for the deepest explicitly set value for a key\n// in a navigationState tree.\nexport function deepestExplicitValueForKey(navigationState, key) {\n  let current;\n  let selected = navigationState;\n\n  while ({}.hasOwnProperty.call(selected, 'children')) {\n    if (!selected.tabs) {\n      // for pushed children, iterate through each, recording key value,\n      // until reaching the selected child\n      for (let i = 0; i < selected.index; i += 1) {\n        if (typeof (selected.children[i][key]) !== 'undefined') {\n          current = selected.children[i][key];\n        }\n      }\n    }\n    // set the new selected child and check for a key value\n    selected = selected.children[selected.index];\n    if (typeof (selected[key]) !== 'undefined') {\n      current = selected[key];\n    }\n  }\n\n  // fallback to the root key value\n  if (typeof (current) === 'undefined') {\n    current = navigationState[key];\n  }\n\n  return current;\n}\n\nexport function assert(expr, failDescription) {\n  if (!expr) {\n    throw new Error(`[react-native-router-flux] ${failDescription}`);\n  }\n}\n\nexport default {\n  deepestExplicitValueForKey,\n  assert,\n};\n"}